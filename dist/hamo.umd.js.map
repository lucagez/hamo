{"version":3,"file":"hamo.umd.js","sources":["../src/hamo.mjs"],"sourcesContent":["/**\n * Internal function that execute every function in an array passing\n * the same set of arguments.\n * @param {array} funcs - array of function that needs to be executed \n * @param  {any} args - arguments passed to array funcs\n */\nconst every = (funcs = [], ...args) => {\n  const { length } = funcs;\n  for (let i = 0; i < length; i++) {\n    funcs[i](...args);\n  }\n};\n\n/**\n * Concatenating function to be used on defined hook.\n * @param {string} when - one of `before`, `after`, `oncebefore`, `onceafter` \n * @param {function} func \n */\nfunction on(when, func) {\n  this.queues[when] = [\n    ...this.queues[when] || [],\n    func\n  ];\n\n  this.handler = this.build();\n}\n\n/**\n * Clear hook's queue relative to passed `when`.\n * @param {string} when - one of `before`, `after`, `oncebefore`, `onceafter` \n */\nfunction off(when) {\n  this.queues[when] = undefined;\n\n  this.handler = this.build();\n}\n\n/**\n * Dynamically buiilding the body of the handler.\n * Building this optimized function lead to 100x performance improvement\n * against an already defined handler with if statements.\n * This function will composed only the actually used hooks.\n * Adding a lot less overhead.\n * If `any` is FALSE (meaning no hooks used) => the normal function is\n * passed.\n * The function is built on each hook/dehook.\n * \n * NOTE: because of scheduled micro-task, the flow of the resulting function is:\n * 1. ONCE BEFORE\n * 2. BEFORE\n * 3. MIDDLE (hooked function)\n * 4. return result of the hooked function\n * 5. ONCE AFTER\n * 6. AFTER\n */\nfunction build() {\n  // QUEUES\n  const { before, oncebefore, after, onceafter } = this.queues;\n\n  const any = oncebefore || before || after || onceafter;\n\n  let body = '';\n\n  /**\n   * BEFORE\n   */\n  if (oncebefore) {\n    body += `this.every(this.queues.oncebefore, ...arguments);`;\n    body += `this.queues.oncebefore = undefined;`;\n  }\n\n  if (before) {\n    body += `this.every(this.queues.before, ...arguments);`;\n  }\n\n  /**\n   * MIDDLE\n   * Executing actual function after the `before` queue.\n   */\n  if (any) {\n    body += `const result = this.func(...arguments);`;\n  }\n\n  /**\n   * AFTER\n   * (microtask executed on nextTick)\n   * NOTE: using Promise for browser compatibility.\n   */\n  if (after || onceafter) {\n    body += `Promise.resolve().then(() => {`;\n    if (onceafter) {\n      body += `this.every(this.queues.onceafter, result, ...arguments);`;\n      body += `this.queues.onceafter = undefined;`;\n    }\n    if (after) {\n      body += `this.every(this.queues.after, result, ...arguments);`;\n    }\n    body += `});`;\n  }\n\n  if (any) {\n    body += `return result;`;\n  }\n\n  // Adding conditions to keep using original function \n  // when there are no defined hooks.\n  return body.length > 0\n    ? new Function(body)\n    : this.func;\n}\n\n/**\n * Hamo, it's latin for `hook`.\n * \n * @param {function} func \n */\nfunction hamo(func) {\n  this.queues = {};\n\n  // Hooked function\n  this.func = func;\n\n  // Dyanmically builded handler.\n  // Hamo starts using the provided function as the\n  // used handler => start with no overhead.\n  // Adding overhead only if hooks are defined.\n  // If all queues are cleared at any point in time, the handler will\n  // be the original function again.\n  this.handler = this.func;\n\n  // Dynamically build the body of the handler function.\n  this.build = build.bind(this);\n  this.every = every.bind(this);\n\n  // Returning the handler function and the `on` / `off` modifiers\n  return [\n    (...args) => this.handler(...args),\n    on,\n    off,\n  ];\n}\n\n// class Hamo {\n//   constructor(func) {\n//     this.queues = {};\n  \n//     // Hooked function\n//     this.func = func;\n  \n//     // Dyanmically builded handler.\n//     // Hamo starts using the provided function as the\n//     // used handler => start with no overhead.\n//     // Adding overhead only if hooks are defined.\n//     // If all queues are cleared at any point in time, the handler will\n//     // be the original function again.\n//     this.handler = this.func;\n  \n//     // Dynamically build the body of the handler function.\n//     this.build = build.bind(this);\n//     this.every = every.bind(this);\n  \n//     // Returning the handler function and the `on` / `off` modifiers\n//     return [\n//       (...args) => this.handler(...args),\n//       on.bind(this),\n//       off.bind(this),\n//     ];\n//   }\n// }\n\nexport default hamo;\n"],"names":["const","every","funcs","length","let","i","args","on","when","func","queues","handler","build","off","undefined","before","oncebefore","after","onceafter","any","body","Function","hamo","bind","this"],"mappings":";;;;;EAAA;;;;;;EAMAA,IAAMC,KAAK,aAAIC,KAAD;iCAAM,GAAG;;;;IACbC;;SACHC,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGF,MAApB,EAA4BE,CAAC,EAA7B,EAAiC;MAC/BH,KAAK,CAACG,CAAD,OAAL,CAAS,OAAGC,IAAZ;;GAHJ;;;;;;;;EAYA,SAASC,EAAT,CAAYC,IAAZ,EAAkBC,IAAlB,EAAwB;SACjBC,MAAL,CAAYF,IAAZ,KACK,KAAKE,MAAL,CAAYF,IAAZ,KAAqB,EAAxB,WACAC,KAFkB,CAApB;SAKKE,OAAL,GAAe,KAAKC,KAAL,EAAf;;;;;;;;EAOF,SAASC,GAAT,CAAaL,IAAb,EAAmB;SACZE,MAAL,CAAYF,IAAZ,IAAoBM,SAApB;SAEKH,OAAL,GAAe,KAAKC,KAAL,EAAf;;;;;;;;;;;;;;;;;;;;;;EAqBF,SAASA,KAAT,GAAiB;;cAEkC,KAAKF;IAA9CK;IAAQC;IAAYC;IAAOC;QAE7BC,GAAG,GAAGH,UAAU,IAAID,MAAd,IAAwBE,KAAxB,IAAiCC,SAA7C;QAEIE,IAAI,GAAG,EAAX;;;;;QAKIJ,UAAJ,EAAgB;MACdI,IAAI,IAAK,mDAAT;MACAA,IAAI,IAAK,qCAAT;;;QAGEL,MAAJ,EAAY;MACVK,IAAI,IAAK,+CAAT;;;;;;;;QAOED,GAAJ,EAAS;MACPC,IAAI,IAAK,yCAAT;;;;;;;;;QAQEH,KAAK,IAAIC,SAAb,EAAwB;MACtBE,IAAI,IAAK,gCAAT;;UACIF,SAAJ,EAAe;QACbE,IAAI,IAAK,0DAAT;QACAA,IAAI,IAAK,oCAAT;;;UAEEH,KAAJ,EAAW;QACTG,IAAI,IAAK,sDAAT;;;MAEFA,IAAI,IAAK,KAAT;;;QAGED,GAAJ,EAAS;MACPC,IAAI,IAAK,gBAAT;KA9Ca;;;;WAmDRA,IAAI,CAACjB,MAAL,GAAc,CAAd,GACH,IAAIkB,QAAJ,CAAaD,IAAb,CADG,GAEH,KAAKX,IAFT;;;;;;;;;EAUF,SAASa,IAAT,CAAcb,IAAd,EAAoB;;;SACbC,MAAL,GAAc,EAAd,CADkB;;SAIbD,IAAL,GAAYA,IAAZ,CAJkB;;;;;;;SAYbE,OAAL,GAAe,KAAKF,IAApB,CAZkB;;SAebG,KAAL,GAAaA,KAAK,CAACW,IAAN,CAAW,IAAX,CAAb;SACKtB,KAAL,GAAaA,KAAK,CAACsB,IAAN,CAAW,IAAX,CAAb,CAhBkB;;WAmBX;;;;;oBACQC,QAAKb,aAAL,CAAa,KAAGL,IAAhB;KADR,EAELC,EAFK,EAGLM,GAHK,CAAP;;;;;;;;;"}