const every=(e=[],...t)=>{const{length:n}=e;for(let r=0;r<n;r++)new Promise(()=>e[r](...t))};function validator(...e){if(["oncebefore","before","after","onceafter"].indexOf(e[0])<0)throw new Error(`Undefined timing ${e[0]}`);if(e[1]&&"function"!=typeof e[1])throw new TypeError("Hook must be of type function")}function on(e,t){validator(e,t),this.queues[e]=[...this.queues[e]||[],t],this.handler=this.build()}function off(e){validator(e),this.queues[e]=void 0,this.handler=this.build()}function build(){const{before:e,oncebefore:t,after:n,onceafter:r}=this.queues,u=t||e||n||r;let o="";return t&&(o+="this.every(this.queues.oncebefore, ...arguments);",o+="this.queues.oncebefore = undefined;"),e&&(o+="this.every(this.queues.before, ...arguments);"),u&&(o+="const result = this.func(...arguments);"),(n||r)&&(o+="Promise.resolve().then(() => {",r&&(o+="this.every(this.queues.onceafter, result, ...arguments);",o+="this.queues.onceafter = undefined;"),n&&(o+="this.every(this.queues.after, result, ...arguments);"),o+="});"),u&&(o+="return result;"),o.length>0?new Function(o):this.func}const hamo=e=>{const t={queues:{},func:e,handler:e,build:build,every:every};return[(...e)=>t.handler(...e),on.bind(t),off.bind(t)]};module.exports=hamo;
