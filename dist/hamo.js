const every=(e=[],...o)=>{const{length:t}=e;for(let n=0;n<t;n++)e[n](...o)};function validator(...e){if(["oncebefore","before","after","onceafter"].indexOf(e[0])<0)throw new Error(`Undefined timing ${e[0]}`);if(e[1]&&"function"!=typeof e[1])throw new TypeError("Hook must be of type function")}function on(e,o){this.queues[e]=[...this.queues[e]||[],o]}function off(e){this.queues[e]=void 0}function build(){const{before:before,oncebefore:oncebefore,after:after,onceafter:onceafter}=this.queues,any=oncebefore||before||after||onceafter;let body=`(${this.async?"async ":""}function handler() {`;return oncebefore&&(body+="this.every(this.queues.oncebefore, ...arguments);",body+="this.queues.oncebefore = undefined;"),before&&(body+="this.every(this.queues.before, ...arguments);"),any&&(body+=`const result = ${this.async?"await ":""}this.func(...arguments);`),(after||onceafter)&&(body+="Promise.resolve().then(() => {",onceafter&&(body+="this.every(this.queues.onceafter, result, ...arguments);",body+="this.queues.onceafter = undefined;"),after&&(body+="this.every(this.queues.after, result, ...arguments);"),body+="});"),any&&(body+="return result;"),body+="})",body.length>0?eval(body):this.func}function wrap(e){return function(...o){validator(...o),e.apply(this,o),this.handler=build.apply(this)}}const hamo=(e,o=!1)=>{if("function"!=typeof e)throw new TypeError("Hooked must be of type function");const t={queues:{},func:e,async:o,handler:e,build:build,every:every};return[(...e)=>t.handler(...e),wrap(on).bind(t),wrap(off).bind(t)]};module.exports=hamo;
